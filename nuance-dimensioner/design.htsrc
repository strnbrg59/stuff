<HTML>

<TITLE>Design of the Java Dimensioner </TITLE>
<CENTER><FONT SIZE=12>Design of the Java Dimensioner </FONT></CENTER>
<CENTER><EM>Ted Sternberg</EM></CENTER>

<H1> Credits </H1>

Matt Lennig wrote the first dimensioner.  It was a C++ program he
later translated to Java.  That Java program, after some work by Dave
Peters on implementing the print button, was the starting point for my
work, which this document describes.

<P>
Chris Toulson has extended the original C++ program, modifying the GUI,
adding memory-utilization and network-utilization calculations,
and developing a simulation study of recognition response latency.

<P>
The rest of this document concerns the Java dimensioner.  The account
here is narrative and concerns the overall design.  For details please
consult the <A HREF="javadoc/tree.html"> javadoc-generated documentation. </A>

<H1> FrontEnd and BackEnd </H1>

The two most important classes in the dimensioner are FrontEnd and
BackEnd.  FrontEnd is the GUI.  BackEnd is where
all the calculations are done.  The division of responsibilities
between FrontEnd and BackEnd is sharp enough, and the
coupling loose enough, that the dimensioner could be easily modified
to employ an alternative FrontEnd or an alternative BackEnd, with no
need to modify any other classes.

<P> BackEnd is only an interface; so far we have one implementation,
and it's called AnalyticalBackEnd (<em>analytical</em> because it uses
the formulas from J.E.Flood's <em>Telecommunications Traffic,
Switching and Networks</em>).  BackEnd exposes six public methods, which
FrontEnd calls.  BackEnd implementations do not call any of FrontEnd's
methods.  Neither manipulates any data in the other.

<H2> FrontEnd </H2>

FrontEnd is a Panel, laid out as a GridBag of other Panels.  Nested in
those are mostly TextFields.  Since all those TextFields need at least
one Label above them (and usually a second Label, or Button, next to
them), we provide class PanelWithTextFieldAndLabel and its subclasses.

<P> FrontEnd has only one non-private method -- its constructor.

<P> A small part of FrontEnd's behavior needs to be different
depending on whether the dimensioner is running as an applet or
standalone.  The necessary specializations are in FrontEnd's
subclasses, FrontEndForApplet and FrontEndForStandalone.

<H2> BackEnd </H2>

All of AnalyticalBackEnd's methods are private, with the exception of
the six public methods declared in the BackEnd interface.  These
public methods -- <TT> solveForBHCV(), solveForCarriedCalls(),
solveForBlockProb(), </TT> etc. -- are provided for use by FrontEnd.
Each of these methods has as its purpose the calculation of one of the
traffic parameters that FrontEnd displays in a TextField.  Each is
passed a TrafficParams object that is a copy of the TrafficParams
object that FrontEnd holds as an instance variable.  None of BackEnd's
members modify any variable inside any other class.

<P> FrontEnd calls BackEnd's public methods when the user presses
FrontEnd's Buttons.

<P> AnalyticalBackEnd has a main() method.  It's for unit testing, a
subject covered below.

<H1> Applet and Standalone Modes </H1>

The dimensioner as a whole has been written so it can run both as a
standalone Java application (i.e. "java Dimensioner" at the command
line) and as a web browser applet.  This trick is accomplished in
class Dimensioner.  Dimensioner, which extends Applet, has an
<TT>init()</TT> method and a <TT>main()</TT> method.  <TT>init()</TT>,
which is where the action begins for applets, constructs an instance
of FrontEnd.  <TT>main()</TT>, the entrypoint for any standalone Java
application, constructs a Panel, and places into that an instance of
FrontEnd.

<H1> Nuance Intranet Access </H1>

The html file that launches the applet uses a <TT>PARAM</TT> tag to indicate
whether the browser running the applet has access to the Nuance
Intranet.  When the browser has such access, several features are
enabled: the print button launches a Perl script to produce a nicely
formatted report, and the Info button causes the browser to jump to an
Intranet web page that documents the highlighted grammar.

<P> Thus, the same .jar file can be distributed to everyone, but the
html file that launches the applet should set the Intranet <TT>PARAM</TT> tag
appropriately for the audience.

<P> Ideally, the applet would determine for itself if it can reach the
Nuance Intranet.  My attempts to make that happen, however, ran into
several still-open problems:

<P> 1. URL.openConnection() doesn't throw an exception even if it's
called on a nonexistent url.

<P> 2. URL.getInputStream() works on
http://tehachapi/~strnbrg/index.html (I'm running Netscape on
tehachapi), but it throws an exception on
http://intranet/provisioning/results.html, even though that's a
valid web page and indeed elsewhere in the FrontEndForApplet class we
even load pages from that directory (in response to the Info button).
The exception I get when I try getInputStream() on intranet etc is
"netscape.security.AppletSecurityException: security.  Couldn't
connect to 'intranet' with origin from 'tehachapi.nuance.com'".  I tried
this on another machine and got the same result.

<H1> Makefile targets and options </H1>

<H2> targets </H2>

<H3> standalone </H3>
produces the class files.  "java Dimensioner" will then run the program.

<H3> applet </H3>
produces a Dimensioner.jar file, placing it (and the associated html
file that points to it) in $HOME/public_html.

<H3> javadoc </H3> 
runs javadoc on the sources, placing the resulting html files in a
subdirectory named javadoc.

<H3> clean </H3>
removes all the class files, and all *~.

<H2> GRAPHICS_MODEL </H2>

Set the GRAPHICS_MODEL variable (near the top of Makefile) to either
<TT>awt</TT> or <TT>swing.</TT> If GRAPHICS_MODEL is set to
<TT>awt</TT>, then dummy implementations in ./javax/swing come into
play; there, we have dummy implementations of JButton, JPanel, etc.

<P> The Swing version looks nicer.  Unfortunately, most web browsers
need to download and install a plug-in before they can display a Swing
applet, and at this writing the plug-in's installation was difficult.
The non-swing (i.e. all-awt) version is therefore an option we want to
have.

<H1> Unit testing </H1>

Run the tester.sh shell script.  If it produces no output, that's
considered success.

<P> Our policy is to have each class test itself by giving it a main()
method, which writes to standard out.  The tester.sh script invokes
each main() method and compares its output to a known-correct output
file called tester.correct-output.  tester.sh uses the Unix diff
utility; that's why no output means success.

<P> So far, only AnalyticalBackEnd has such a testing main() method.

<H1> CloneGrammarDialog </H1>

An instance of this class pops up when the user clicks on the "clone"
button.  It is an error to then press the "save" button in the Dialog,
without first having selected a new name for the grammar.  After any
valid press of the "save" button, the newly defined grammar appears at
the bottom of the list that pops up when one presses the Choice widget
labeled "Select grammar".


<H1> GrammarDatabase </H1>

GrammarDatabase.java is generated by the buildGD.sh shell script.
buildGd.sh starts from GrammarDatabase.java-template, and inserts a
list of Grammar specifications from grammars.dat, an ordinary text
file.  The insertion is into a static Vector member of
GrammarDatabase.

<P> GrammarDatabase's public methods retrieve information about that
Vector of Grammars, and append to it.  AnalyticalBackEnd calls the
size() and elementAt() methods of GrammarDatabase.  The only place
GrammarDatabase is ever modified is where CloneGrammarDialog calls the
append() method.

<P> The grammar names in GrammarDatabase are what appears in the
drop-down grammar menu.

<H1> GrammarList </H1>

The grammar model widget represents a single GrammarList object.
FrontEnd owns that object and passes it to BackEnd for calculating
required RUs.  

<P> Internally, a GrammarList stores its data in a Vector of
GrammarAndModifiers objects.  A GrammarAndModifier object consists of
a Grammar (which is a name, an LU, a duration and the URL of the
intranet page that documents the grammar), a number-of-requests, and a
verification flag.  That's the only place we record the fact that a
grammar is to be processed with verification.

<H1> Verification </H1>

Verification adds 0.5 LU to whatever a grammar's LU already is.  If a
particular utterance interests us only for verification, i.e. we don't
even try to recognize the utterance, then the LU is 0.5.  These are
rough estimates, but they are what's been built into the program and
this document is about the design of the program.

<P> When the user adds a grammar to the grammar model, he may check
the verification checkbox, just as he may enter a number for
number-of-requests.  The effect of doing so is that the newly created
item in the grammar model -- an object of type GrammarAndModifers --
records the verification flag in a boolean field.  BackEnd methods
look for that verify flag and add 0.5 LU to the associated grammar's
LU.

<P> We don't have any automatic way to handle utterances that are for
verification only, i.e. where recognition is not done.  We could have
an extra checkbox called "verification-only", but that would add
clutter for little gain.  The user can obtain the required
functionality by cloning the grammar and creating a new grammar with
LU 0.5.

<H1> dimensioner-report </H1>

This is a Perl script that summarizes the contents of the various
textfields in nice html format.  The script gets its input from the
handler for the "Print Page" button -- see
FrontEnd.printButton_MousePressed().

<P> When the dimensioner runs as an applet, it does one of two things
depending on whether the applet is running on a web browser that can
access the Nuance Intranet.  If the browser has Nuance Intranet
access, then the print button invokes dimensioner-report as a CGI
program, passing it the contents of the various textfields in the CGI
GET style; dimensioner-report parses that information and writes its
output to stdout, which the applet receives and displays in the
browser.  See FrontEndForApplet.printReport().  If the web browser
does not have Nuance Intranet access, then a summary of all the
information in the display gets printed to a dialog box that pops up.

<P> When the dimensioner runs standalone, we don't use
dimensioner-report; that would require users to have Perl installed
(or we'd have to rewrite dimensioner-report in Java).  So in
standalone mode, FrontEndForStandalone.printReport() prompts the user
for a file name, and then prints a report into that file.  This report
is not as nicely formated as the web page the applet produces, but
both present the same information.

<H1> javax/swing directory </H1>

The directory that contains most of the source files -- BackEnd.java,
FrontEnd.java etc. -- has a subdirectory javax/swing.  That directory
contains dummy implementations of Java Swing classes such as JButton,
JPanel and JLabel.  Their role is to enable us to compile the
dimensioner either with or without Swing functionality, while
maintaining a single code base.

<P> For more details on the swing/awt switching scheme, please see the
section on makefile targets and options.

<H1> CGI </H1>

The CGI version puts the processing on the server side.  The client's
browser starts at a special "executable URL".  What the browser sees
there is a web page that looks like a GUI -- the dimensioner GUI.  A
mouse click on any of the buttons sends a request to the server: that
request takes the form of a URL plus an argument string that
encapsulates the state of the web page -- the contents of the text
fields and grammar model, the states of the checkboxes, etc.  The
server sends back a stream of HTML text, which the browser renders as
the same web page as before, but with the results of whatever
calculation was requested (find required speech channels, find
required RU, etc).

<P> There is really only one CGI form.  A template of it may be found
in cgiForm.html.  This file contains conventional html text, but it
also refers to variables and methods available within
CGIForm.printPage().  The makefile inserts cgiForm.html into
CGIForm.printPage() within the file CGIForm.java-template, producing
thereby a file the Java compiler sees: CGIForm.java.  At runtime, the
contents of cgiForm.html are thus code that prints HTML tags and, by
referring to program variables, inserts the proper values into
textfields such as "Total RU required".

<P> The CGI form's ACTION is a script that calls a Java program built
from most of the code that's used in the Java standalone and applet
versions.  That Java program does the right thing by looking at the
identity of the SUBMIT button that was pushed.  The SUBMIT buttons
correspond to the familiar buttons of the "pure" Java versions -- find
required speech channels, find required RUs, add grammar, delete
grammar, etc.

<P> The sequence is interpret-evaluate-display.  First, we update
internal variables so that they represent the current state of the
form (i.e. the numbers in the text fields, the contents of the grammar
menu, the state of the checkboxes).  Next, we perform the action
associated with the button that was pushed (the CGI SUBMIT button).
Finally, we send a new version of the web page -- complete with
calculated results -- by calling CGIForm.printPage().

</HTML>




