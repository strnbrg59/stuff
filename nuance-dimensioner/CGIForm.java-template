/*
  File:        CGIForm.java-template
  Author:      Sternberg
  Date:        October 1999
  Description: 
    Basis for the CGI program that produces the HTML page that the user 
    thinks of as the "Dimensioner GUI".

    A script, buildCGIForm-java, takes this
    file and inserts into it the material from cgiForm.html.  The 
    cgiForm.html file is stuff to "println", but there's more than just 
    text there; some of the stuff to print is the names of program
    variables: that's how we get useful values out to the web browser.
*/

import java.util.*;

public class CGIForm
{
    public CGIForm()
    {
        m_backend = new AnalyticalBackEnd();
        m_traffic_params = new TrafficParams();
        initializeTrafficParams();

        m_grammar_choice = new CGIGrammarChoice();
        refreshGrammarChoice();

        m_grammar_list = new CGIGrammarList(1);
        m_cgi_query_hash = null;
    }

    /** React to anything the user has done to the web page -- data he's
     *  entered, and the submit button he's pushed.
    */
    public void processQuery( String cgi_query_string )
    {
        try 
        { 
            m_cgi_query_hash = parseCGIQueryString( cgi_query_string );
            updateFromCGIForm();
            dispatchOnSubmit(); 
        }
        catch( Exception e )
        {
            System.out.println( "<CENTER>" );
            System.out.println("<FONT SIZE=+3 COLOR=#FF0000>" +
              e.toString() + "</FONT>" );
            System.out.println( "</CENTER>" );
            System.out.flush();
            System.exit(1);
        }
    }

    /** Convert '+' to ' ', and interpret anything after % as hexadecimal. */
    static private StringBuffer convertCGIQueryStringSpecialCharacters( 
      StringBuffer str )
    {
        StringBuffer result = new StringBuffer();
        for( int i=0;i<str.length();i++ )
        {
            if( str.charAt(i) == '+' )
            {
                result.append( ' ' );
            } else
            if( str.charAt(i) == '%' )
            {
                StringBuffer hex = new StringBuffer();
                hex.append( str.charAt(i+1));
                hex.append( str.charAt(i+2));
                char charRep = 
                  (char)((Byte.valueOf(new String(hex),16)).intValue());
                result.append( charRep );
                i += 2;
            } else
            {
                result.append( str.charAt(i) );
            }
        }
        
        return result;
    }

    /** From stdin, get a GET-style string of CGI arguments, and store them
     *  in a Hashtable.  In the CGI string, the key-value pairs are separated
     *  by "&".  The key and value are separated by "=".  Spaces (0x20) and 
     *  other non-letter characters are represented by their hex codes.
     *
     *  @arg cgi_query_string This is args[0] from main().
    */
    static public Hashtable parseCGIQueryString( String cgi_query_string )
    {
        Hashtable hash = new Hashtable();
        StringTokenizer st = new StringTokenizer( cgi_query_string, "&" );
        while( st.hasMoreElements() )
        {
            String tok = new String( st.nextToken() );
            StringTokenizer subST = new StringTokenizer( tok, "=" );

            StringBuffer theKey = new StringBuffer(subST.nextToken());
            theKey = convertCGIQueryStringSpecialCharacters( theKey );

            StringBuffer theValue = null;
            if( subST.hasMoreElements() )
            {
                theValue = new StringBuffer( subST.nextToken() );
                theValue = convertCGIQueryStringSpecialCharacters( theValue);

                hash.put( new String(theKey), new String(theValue) );
            }
            else
            {
                hash.put( new String(theKey), new String("") );
            }
        }

        return hash;
    }

    /** Update the TrafficParams arg, based on what's in the widgets on the
     *  CGI form (which have already been captured in m_cgi_query_hash).
    */
    private void updateFromCGIForm() throws BackEndException
    {
        Hashtable hash   = m_cgi_query_hash; // shorthand
        TrafficParams tp = m_traffic_params; // shorthand

        Double d = new Double(0.0);

        tp.set_bhcv( Integer.parseInt( (String)hash.get("bhcv") ) );

        tp.set_holding_time(
          Integer.parseInt(((String)hash.get("holdingTime")).trim()));

        d = d.valueOf( ((String)hash.get("blockProb")).trim());
        tp.set_block_prob( d.doubleValue() );

        tp.set_carried_calls( 
          Integer.parseInt( ((String)hash.get("carriedCalls")).trim() ));

        d = d.valueOf( ((String)hash.get("offeredTraffic")).trim() );
        tp.set_offered_traffic( d.doubleValue() );

        tp.set_speech_channels( 
          Integer.parseInt(((String)hash.get("speechChannels")).trim()));

        d = d.valueOf( ((String)hash.get("latencyThreshold")).trim() );
        tp.set_latency_threshold( d.doubleValue() );

        d = d.valueOf( ((String)hash.get("latencyProb")).trim() );
        tp.set_latency_prob( d.doubleValue() );

        d = d.valueOf( ((String)hash.get("totalRuRequired")).trim() );
        tp.set_required_ru( d.doubleValue() );

        d = d.valueOf( ((String)hash.get("minRuPerCPU")).trim() );
        tp.set_min_ru_per_cpu( d.doubleValue() );

        d = d.valueOf( ((String)hash.get("requestsPerCall")).trim() );
        tp.set_requests_per_call( d.doubleValue() );

        if( hash.get("twopass") == null )
            tp.set_twopass(false);
        else
            tp.set_twopass(true);

        d = d.valueOf( ((String)hash.get("ruPerServer")).trim());
        tp.set_ru_per_server( d.doubleValue() );

        d = d.valueOf( ((String)hash.get("memoryRequired")).trim() );
        tp.set_memory( d.doubleValue() );

        if( hash.get("verification") == null )
            m_verification = false;
        else
            m_verification = true;

        // If there were extra grammars, make the dropdown menu reflect them.
        if( CGIGrammarDatabase.loadExtraGrammars( hash ) > 0 )
        {   
            refreshGrammarChoice();
        }
        m_grammar_choice.setSelected( hash );

        m_grammar_list.loadFromHiddenField( hash );
        m_grammar_list.setSelected( hash );

    }

    private void refreshGrammarChoice()
    {
        m_grammar_choice.removeAll();
        for( int i=0;i<CGIGrammarDatabase.size();i++ )
        {
            m_grammar_choice.addItem(CGIGrammarDatabase.elementAt(i));
        }
    }

    /** Upon the press of any submit-type button, perform the desired action.
     *  That could be calling the appropriate solveFor... method, or 
     *  manipulating the grammar model.
     *
    */
    private void dispatchOnSubmit() throws BackEndException
    {
        Hashtable hash = m_cgi_query_hash;      // shorthand
        TrafficParams tp = m_traffic_params;    // shorthand
        CGIGrammarList grams = m_grammar_list;  // shorthand

        if( ((String)hash.get("submit")).equals( "Busy hour call attempts" ))
        {
            tp.set_bhcv( m_backend.solveForBHCV(tp) );
            tp.set_carried_calls( m_backend.solveForCarriedCalls(tp) );
            tp.set_offered_traffic( m_backend.solveForOfferedTraffic(tp) );
        } else 
        if( ((String)hash.get("submit")).equals(
          "Probability of blocked calls"))
        {
            tp.set_block_prob( m_backend.solveForBlockProb(tp));
            tp.set_carried_calls( m_backend.solveForCarriedCalls(tp) );
            tp.set_offered_traffic( m_backend.solveForOfferedTraffic(tp) );
        } else
        if( ((String)hash.get("submit")).equals( "Speech channels" ))
        {
            tp.set_speech_channels( m_backend.solveForSpeechChannels(tp));
            tp.set_carried_calls( m_backend.solveForCarriedCalls(tp) );
            tp.set_offered_traffic( m_backend.solveForOfferedTraffic(tp) );
        } else
        if( ((String)hash.get("submit")).equals( 
          "Find recognition power requirements" ))
        {
            // Check for empty grammar model.  BackEnd's response is to pop
            // up a warning dialog; if we let it get that far, the program
            // just hangs.
            if( grams.getItemCount() == 0 )
            {
                CGIForm.println( "<HR> *** Empty grammar model! *** <HR>" );
                System.exit(1);
            }
            tp.set_required_ru(m_backend.solveForRecognitionPower(tp,grams));
            tp.set_min_ru_per_cpu( 
              m_backend.solveForMinRUPerCPU( grams ));
        } else
        if( ((String)hash.get("submit")).equals("Find memory requirements" ))
        {
            // Check for empty grammar model.  BackEnd's response is to pop
            // up a warning dialog; if we let it get that far, the program
            // just hangs.
            if( grams.getItemCount() == 0 )
            {
                CGIForm.println( "<HR> *** Empty grammar model! *** <HR>" );
                System.exit(1);
            }
            tp.set_required_ru(m_backend.solveForRecognitionPower(tp,grams));
            tp.set_min_ru_per_cpu( 
              m_backend.solveForMinRUPerCPU( grams ));
            tp.set_memory( m_backend.solveForMemory(tp,grams));
        } else
        if( ((String)hash.get("submit")).equals( "Add grammar" ))
        {
            m_grammar_list.addElement( m_grammar_choice.getSelectedGrammar(),
                                       tp.get_requests_per_call(),
                                       m_verification);   
        } else
        if( ((String)hash.get("submit")).equals( "Delete grammar" ))
        {
            int selected = m_grammar_list.getSelectedIndex();
            if( selected != -1 )
            {
                // FIXME: print a warning if none is selected.
                m_grammar_list.delItem( selected );
            }
        } else
        if( ((String)hash.get("submit")).equals( "Clone grammar" ))
        {
            int i=0;
            // There's nothing to do here.  See the !!-prefixed code in
            // cgiForm.html.
        } else
/*
        // We don't support the Grammar Info button anymore.
        if( ((String)hash.get("submit")).equals( "Grammar info" ))
        {
            CGIGrammarDatabase.gotoGrammarWebPage( 
              m_grammar_choice.getSelectedGrammar() );
            System.exit(0);
        } else
*/
        if( ((String)hash.get("submit")).equals( "New grammar" ))
        {
            int i=0; // There's nothing to do.  The name, lu and duration
            // are saved in text fields, and the next invocation of this
            // program will load their contents in loadExtraGrammars().
        }
        else
        {
            // FIXME: Display an error web page.
            tp.set_bhcv( -999 );
            tp.set_required_ru( -999 );
            tp.set_block_prob( -999 );
        }
    }


    /** Converts true to "CHECKED", false to "", and thus adapts Java boolean
     *  semantics to CGI checkbox semantics.
    */
    private String checkboxTruthAdaptor( boolean value )
    {
        if( value == false )
            return new String("");
        else
            return new String("CHECKED");
    }

    /** Fill in values so we start with something other than all zeros; if
     *  the user presses a solveFor button when the textfields are all zeros,
     *  that's an error -- frustrating and confusing.
    */
    private void initializeTrafficParams()
    {
        m_traffic_params.set_bhcv( 3600 );
        m_traffic_params.set_holding_time( 120 );
        m_traffic_params.set_block_prob( 0.02 );
        m_traffic_params.set_speech_channels( 133 );

        m_traffic_params.set_requests_per_call(0.0);

        m_traffic_params.set_latency_threshold( 2.0 );
        m_traffic_params.set_latency_prob( 95.0 );
        m_traffic_params.set_ru_per_server( 20.0 );
    }

    /** Output that's an essential part of the dynamic web page. */
    public static void print( String s )
    {
        System.out.print( s );
    }
    /** Output that's an essential part of the dynamic web page. */
    public static void println( String s )
    {
        System.out.println( s );
    }
    /** Debug output */
    public static void trace( String s )
    {
        System.out.print( s );
    }
    /** Debug output */
    public static void traceln( String s )
    {
        System.out.println( s );
    }

    //
    // Data members
    //
    private AnalyticalBackEnd m_backend;       // Queueing theory algorithms.
    private TrafficParams     m_traffic_params; // Program's notion of
                                                // what's on the CGI form.
    private CGIGrammarChoice  m_grammar_choice; // CGI selection list.
    private CGIGrammarList    m_grammar_list;   // The current grammar model.
    private Hashtable         m_cgi_query_hash; // From CGI query string.
    private boolean           m_verification;   // state of checkbox


    /** Print the dynamic web page.
     *
     *  We put this method at the bottom of the file because this is
     *  where buildCGIForm-java.sh comes into play and transforms this
     *  file into CGIForm.java.  So it's easier for tracking down compiler
     *  errors if all the line numbers up to here correspond to those in
     *  the file the compiler sees -- CGIForm.java.
    */
    public void printPage()
    {
        TrafficParams tp = m_traffic_params; // short: used in included text

        // In cgiForm.html we can't embed an expression that contains quotes.
        // That's why we're defining the following variable here, so we can
        // refer to it.
        String extraGrammars = new String("");
        if( (m_cgi_query_hash != null)
        &&  (m_cgi_query_hash.containsKey("extraGrammars")) )
        {
            extraGrammars = (String)m_cgi_query_hash.get("extraGrammars");
        }

        // Do not edit the next two lines!!!
        // -- addHTML starting here
        // -- end of addHTML section

    }
}

