/*
**   _______              __
**  / ___/ /  ___  __ _  / /  ___
** / /__/ _ \/ _ \/  ' \/ _ \/ _ \
** \___/_//_/\___/_/_/_/_.__/\___/ 
**
** This software is copyright (C) by the Lawrence Berkeley
** National Laboratory.  Permission is granted to reproduce
** this software for non-commercial purposes provided that
** this notice is left intact.
** 
** It is acknowledged that the U.S. Government has rights to
** this software under Contract DE-AC03-765F00098 between
** the U.S. Department of Energy and the University of
** California.
**
** This software is provided as a professional and academic
** contribution for joint exchange.  Thus it is experimental,
** is provided ``as is'', with no warranties of any kind
** whatsoever, no support, no promise of updates, or printed
** documentation.  By using this software, you acknowledge
** that the Lawrence Berkeley National Laboratory and
** Regents of the University of California shall have no
** liability with respect to the infringement of other
** copyrights by any part of this software.
**
*/
// Author: Ted Sternberg
#ifndef INCLUDED_HETEROMAP_HIMPL
#define INCLUDED_HETEROMAP_HIMPL

#include "Trace.h"
#include "HeteroMap.h"
#include <sstream>
using std::ostringstream;

/** This is the base class of the values we store in our HeteroMap.  We need
 *  to wrap the things we actually store, so we can use dynamic_cast on them.
 *  The virtual destructor gives us the vtable, which is necessary if we want to
 *  use dynamic_cast.
*/
class TypeWrapperBase
{
  public:
    virtual ~TypeWrapperBase() { }
};

template<class T> class TypeWrapper : public TypeWrapperBase
{
  public:
    TypeWrapper( T t ) : m_rep(t) { }
    virtual ~TypeWrapper() { }
    T const & Get() const { return m_rep; }
  private:
    T m_rep;
};

template<class KEY_T> HeteroMap<KEY_T>::HeteroMap()
{
}

template<class KEY_T> HeteroMap<KEY_T>::~HeteroMap()
{
    for( typename map<KEY_T, TypeWrapperBase const *>::const_iterator iter =
            m_rep.begin();
         iter != m_rep.end();
         ++iter )
    {
        delete iter->second;
    }
}

/** Store a pointer to a copy of arg value.
 *  Arg status is 0 by default.  If !0, then set it to STATUS_OK or
 *  STATUS_DUPLICATE.
 *  Arg value can't be a char*.  If you want to store "foobar", then pass in
 *  string("foobar").
 *  If arg key duplicates the key of an existing item, we replace the old item.
*/
template<class KEY_T> template<class T> void
HeteroMap<KEY_T>::Put( KEY_T key, T const & value, Status * status )
{
    Trace t("HeteroMap::Put()");
/*
    ostringstream ost;
    ost << "(" << key << "," << value << ")";
    t.Info( "%s", ost.str().c_str() );
*/
    if( status )
    {
        typename map<KEY_T, TypeWrapperBase const *>::const_iterator i =
            m_rep.find( key );
        if( i == m_rep.end() )
        {
            *status = STATUS_OK;
        } else
        {
            *status = STATUS_DUPLICATE;
            delete m_rep[key];
        }
    }

    TypeWrapper<T> * item = new TypeWrapper<T>(value);
    m_rep[key] = item;
}

  
/** Retrieve an object.  When calling, indicate the type through the dummy arg,
 *  rather than in angle brackets, i.e. "double * dummy; Get( "pi", dummy )",
 *  rather than Get<double>("pi").  This is because, at least as of gcc 3.0.1,
 *  the latter will not compile if called from a member function of a templated
 *  class.  (But it does work on KCC and icX.)
 *  Arg status is 0 by default.  If !0, then set it to STATUS_OK,
 *  STATUS_NOT_FOUND, or STATUS_WRONG_TYPE.  With status set to 0, we omit
 *  sanity checks.
*/
template<class KEY_T> template<class T> T const &
HeteroMap<KEY_T>::Get( KEY_T key, T const * dummy, Status * status ) const
{
    Trace t("HeteroMap::Get()");

    typename map<KEY_T, TypeWrapperBase const *>::const_iterator i =
        m_rep.find( key );
    TypeWrapper<T> const * result;
    if( status )
    {
        static T irrelevantValue; // something to return if function fails.
        *status = STATUS_OK;

        if( i == m_rep.end() )
        {
            //t.Warning( "Failed to find attribute %s.", key.c_str() );
            *status = STATUS_NOT_FOUND;
            return irrelevantValue;
        }

        result = dynamic_cast<TypeWrapper<T> const *>(i->second);
        if( !result )
        {
            *status = STATUS_WRONG_TYPE;
            t.Error( "Wrong type." );
            return irrelevantValue;
        }
    } else
    {
        result = (TypeWrapper<T> const *)(i->second);
    }

    return result->Get();
}


template<class KEY_T> void
HeteroMap<KEY_T>::UnitTest()
{
    Trace t("HeteroMap::UnitTest()");
    Status status;
    Put( "seventeen", 17, &status );
    Put( "pi", 3.14159, &status );

    Put( "a string", string("a string"), &status );

    int * idummy(0);
    double * ddummy(0);
    string * sdummy(0);

    ostringstream ost;

    ost << "Get(\"seventeen\")=" << Get( "seventeen", idummy, &status);
    t.Info( ost.str().c_str() );    
    ost.str("");  // resets ost
    ost << "Get(\"pi\")=" << Get( "pi", ddummy, &status );
    t.Info( ost.str().c_str() );    
    ost.str("");
    ost << "(Deliberate error:) Get(\"pi\")=" << Get( "pi", idummy, &status );
    t.Info( ost.str().c_str() );    
    ost.str("");
    ost << "Get(\"a string\")=" << Get( "a string", sdummy, &status );
    t.Info( ost.str().c_str() );    
}

#endif // INCLUDED_HETEROMAP_HIMPL
