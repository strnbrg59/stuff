/*
**   _______              __
**  / ___/ /  ___  __ _  / /  ___
** / /__/ _ \/ _ \/  ' \/ _ \/ _ \
** \___/_//_/\___/_/_/_/_.__/\___/ 
**
** This software is copyright (C) by the Lawrence Berkeley
** National Laboratory.  Permission is granted to reproduce
** this software for non-commercial purposes provided that
** this notice is left intact.
** 
** It is acknowledged that the U.S. Government has rights to
** this software under Contract DE-AC03-765F00098 between
** the U.S. Department of Energy and the University of
** California.
**
** This software is provided as a professional and academic
** contribution for joint exchange.  Thus it is experimental,
** is provided ``as is'', with no warranties of any kind
** whatsoever, no support, no promise of updates, or printed
** documentation.  By using this software, you acknowledge
** that the Lawrence Berkeley National Laboratory and
** Regents of the University of California shall have no
** liability with respect to the infringement of other
** copyrights by any part of this software.
**
*/
/* provided as a modification from source material derived from
   the VTK distribution.  In accordance with VTK software agreement
   the following also holds:
=========================================================================

Copyright (c) 1993-2000 Ken Martin, Will Schroeder, Bill Lorensen 
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * Neither name of Ken Martin, Will Schroeder, or Bill Lorensen nor the names
   of any contributors may be used to endorse or promote products derived
   from this software without specific prior written permission.

 * Modified source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=========================================================================*/

#ifndef __vtkChomboReaderImpl_h
#define __vtkChomboReaderImpl_h

/**
 * This file is meant for inclusion only in vtkChomboReader.cxx, and nowhere
 * else.
 *
 * See comments in vtkChomboReader.h.
*/

#include <cassert>
#include <iostream>
#include <string>
#include "vtkStructuredPointsSource.h"
#include "vtkVoidArray.h"
#include "../data_access/VisualizableDataset.h"


/** Table, mostly of flags, to keep track of which levels and, within them,
 *  which boxes, we want to load and serve to clients.
 *  Boxes are always taken to be real, not subdivided, boxes.  If we happen to
 *  be working with subdivided boxes, we consider an entry to refer to
 *  the set of subdivided boxes that arose from that real box.
*/
class VisibleLevelsAndBoxes
{
  public:
    void InitLevel( int level, int numBoxes );
    bool GetLevelVisible( int level ) const;
    void SetLevelVisible( int level, bool true_false );
    bool GetBoxVisible( int level, int box ) const;
    void SetBoxVisible( int level, int box, bool true_false );
  private:
    typedef
        map<int,                // level
            pair<bool,          // level is visible
                 vector<bool>   // one entry per real box, true iff visible.
           > > rep_type;
    rep_type m_rep;
};

    

/** The FABs we're passing to the VTK pipeline, plus info on the levels and
 *  components they belong to.
 *  Behaves like a std::vector.
*/
template<class REAL_T>
class VisibleFabInfo
{
  public:
    // Ctors, dtor, operator= : default is fine.

    // STL-ish.
    typedef typename
        vector<boost::intrusive_ptr<FAB<REAL_T> > >::const_iterator IterType;
    IterType begin() const;
    IterType end() const;
    void clear();
    void push_back( boost::intrusive_ptr< FAB<REAL_T> > fab,
                    int level, int component );
    void reserve( int );
    unsigned size() const;

    boost::intrusive_ptr<FAB<REAL_T> > GetFAB( int i ) const;
    int                                GetLevel( int i ) const;
    int                                GetComponent( int i ) const;

    bool contains_fab( boost::intrusive_ptr< FAB<REAL_T> > fab ) const;

  private:
    vector< boost::intrusive_ptr<FAB<REAL_T> > > m_fabs;
    vector<int>                                  m_levels;
    vector<int>                                  m_components;
};

template<class REAL_T>
class vtkChomboReaderImpl : public vtkChomboReader
{
  public:
    //
    // Constructor and destructor.
    //
    vtkChomboReaderImpl( char const * infileName, int dimensionality, Status *);
    vtkChomboReaderImpl( vtkChomboReader * that,  int dimensionality, Status *);
    virtual ~vtkChomboReaderImpl();

    //
    // Overloadings of base class methods.
    //
    virtual char const *           GetClassName() const
                                       { return "vtkChomboReader";}
    void                           PrintSelf(ostream& os, vtkIndent indent);
    virtual vtkStructuredPoints *  GetOutput();
    virtual unsigned long          GetMTime();
    void                           Execute();

    //
    // Information about the entire HDF5 dataset.
    //
    int    * GetDataCentering() const;
    double * GetCoordinateOrigin() const;
    int    * GetDataCenteringPermuted() const;
    int    * GetDomainExtents() const;
    double * GetDomainExtentsXYZ() const;
    int      GetNumComponents() const;
    int *    GetBoxOrigin(int level,int boxNum) const;
    double * GetBoxExtentsXYZ(int level,int boxNum,int visiblePartOnly) const;
    double   GetDatum( int level, int boxNum, int component,
                       int i, int j, int k ) const;
    int      GetFArray( int level, int boxNum, int component ) const;
    int      GetEnclosingBoxNumXYZ( int level, REAL_T x, REAL_T y, REAL_T z );
    int      GetLevelNumBoxes(int level) const;
    int      GetLevelNumRealBoxes(int level) const;
    double * GetLevelDx(int level) const;
    double   GetLevelDt(int level) const;
    double   GetLevelTime(int level) const;
    double * GetLevelComponentRange( int level, int component ) const;
    int      GetNumLevels() const;
    double * GetVisibleRange() const;
    double * GetConstrainedVisibleRange( double lo, double hi ) const;
    char const * GetComponentName( int c ) const;
    int    * GetBoxDims( int level, int boxNum ) const;
    int      GetNumEBs() const;
    void     SetEBIndex( int i );
    int    * GetDimensions( int level, int boxNum, int axisNum,
                            int padded, int realBox ) const;
    double * GetSpacing( int level, int axisNum ) const;
    double * GetOrigin( int level, int boxNum, int axisNum,
                        int padded, int realBox) const;
    double * GetBounds( int level, int boxNum, int axisNum,
                        int padded, int realBox) const;

    //
    // Information about the state of the vtkChomboReader.
    //
    int      GetNumPieces() const { return m_visibleFabInfo.size(); }
    int      LevelIsVisible( int level ) const;
    int      GetFinestVisibleLevel() const;
    int      GetCurrentComponentNum() const { return m_currentComponentNum; }
    char const * GetCurrentComponentName() const;
    int      GetVisibleBoxLevel(int boxNum) const;      // Arg boxNum is...
    int      GetVisibleBoxNum(int boxNum) const;        // ...an index...
    int      GetEBIsVisible() { return m_ebIsVisible; }
    int      PlaneIntersectsBox(
                int level, int box,
                char planeDirection, double planePosition ) const;
    int      Is3DMode() const;
    int      IsSlicingMode() const;
    char     GetSlicingDirection() const;
    double   GetSlicingPosition() const;
    int      GetAlwaysUseRealBoxes() const { return m_alwaysUseRealBoxes; }
    int      GetAlwaysUsePaddedBoxes() const { return m_alwaysUsePaddedBoxes; }
    int      GetGhostCellsSuppliedByUser() const;
    double * GetAnisotropicFactors() const;
    double   GetDistanceToEB( double x, double y, double z,
                              int level, int ebID ) const;
    int      GetCurrentPieceIndex() const;
    int      GetCurrentPieceLevel() const;
    int      GetCurrentPieceBoxNum() const;
    int      CurrentPieceIsPadded() const;
    int      CurrentPieceIsReal() const;

    //
    // Control over the state of the vtkChomboReader.
    //
    int      SetPiece( int boxNum, char axis, double axisPosition );
    void     ShowLevel(int i);
    void     HideLevel(int i);
    void     HideBox(int lev, int b );
    void     ShowBox(int lev, int b );
    void     HideBoxes(int lev, vtkIntArray * bb );
    void     ShowBoxes(int lev, vtkIntArray * bb );
    void     HideAllBoxes(int lev );
    void     ShowAllBoxes(int lev );
    void     SetCurrentComponentName( char const * name );
    void     SetCurrentComponentNum( int n );
    void     SetEBIsVisible( int one_or_zero ) { m_ebIsVisible = one_or_zero; }
    void     SetSlicingDirection( char direction );
    void     SetSlicingPosition( double position );
    void     SetAlwaysUseRealBoxes( int yesno );
    void     SetAlwaysUsePaddedBoxes( int yesno );
    void     SetVtkHierarchicalBoxHack( int yesno );
    void     PinFAB( int level, int boxNum, int component ) const;
    void     UnpinFAB( int level, int boxNum, int component ) const;
    void     SetAnisotropicFactors( float x, float y, float z );
    void     SetDebugLevel( int d ) const;
    void     SetOriginShift( double dx0, double dy0, double dz0,
                             double dxL, double dyL, double dzL );
    void     SetOptimizationMode( int memory_or_speed );

    // Output
    void     DumpAscii() const;
    void     DumpHDF5( char const * outfilename ) const;

    // Particles
    int /* ptr to REAL_T */ GetParticleComponent( const char * name ) const;
    double GetParticleCoordinate( int particleNumber,
                                  const char * compName ) const;
    int GetNumParticles() const;
    int GetNumParticleComponents() const;
    char const * GetParticleComponentName( int serialNumber ) const;
    double GetParticleComponentRangeMin( char const * name ) const;
    double GetParticleComponentRangeMax( char const * name ) const;

    // Bridge to Data API.
    int /* VisualizableDataset* */ GetVisualizableDatasetPtr() const;

private:
    //
    // Private methods.
    //
    void FlattenHierarchy( bool finestLevelHasChanged );
    void ExecuteEB( vtkStructuredPoints * output );
    void InitializeVisibleLevelsAndBoxes();

    //
    // State.
    //
    int const                                       m_hdf5Dimensionality;
    int                                             m_slicingMode;
    char                                            m_slicingDirection;
    double                                          m_slicingPosition;
    vtkTimeStamp*                                   m_fileTimeStamp;
    boost::shared_ptr<VisualizableDataset<REAL_T> > m_visdat;
    int                                             m_currentComponentNum;
    VisibleLevelsAndBoxes                           m_visibleLevelsAndBoxes;
    VisibleFabInfo<REAL_T>                          m_visibleFabInfo;
    boost::intrusive_ptr< FAB<REAL_T> >             m_currentVisibleFAB;
    int                                             m_currentPieceIndex;
    int                                             m_ebIndex;
    int                                             m_ebIsVisible;
    int                                             m_finestVisibleLevel;
    int                                             m_prevFinestVisibleLevel;
    int                                             m_alwaysUseRealBoxes;
    int                                             m_alwaysUsePaddedBoxes;
    double                                          m_originShift0[3];
    double                                          m_originShiftL[3];
    int                                             m_vtkHierarchicalBoxHack;

    double *       m_dblBuf; // Return value from many getters.
    int    *       m_intBuf;
    mutable string m_strBuf;

    struct ChomboEBConsts
    {
        static char const * const s_fraction;
        static char const * const s_xnormal;
        static char const * const s_ynormal;
        static char const * const s_znormal;
        static char const * const s_distance;

        // Size of buffer big enough to hold the longest of the above strings:
        static int  const         s_longestStrlen;
    };
};

#endif
