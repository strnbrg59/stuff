/*
**   _______              __
**  / ___/ /  ___  __ _  / /  ___
** / /__/ _ \/ _ \/  ' \/ _ \/ _ \
** \___/_//_/\___/_/_/_/_.__/\___/ 
**
** This software is copyright (C) by the Lawrence Berkeley
** National Laboratory.  Permission is granted to reproduce
** this software for non-commercial purposes provided that
** this notice is left intact.
** 
** It is acknowledged that the U.S. Government has rights to
** this software under Contract DE-AC03-765F00098 between
** the U.S. Department of Energy and the University of
** California.
**
** This software is provided as a professional and academic
** contribution for joint exchange.  Thus it is experimental,
** is provided ``as is'', with no warranties of any kind
** whatsoever, no support, no promise of updates, or printed
** documentation.  By using this software, you acknowledge
** that the Lawrence Berkeley National Laboratory and
** Regents of the University of California shall have no
** liability with respect to the infringement of other
** copyrights by any part of this software.
** 
** Author: Ted Sternberg
** Date:   November 21, 2003
*/

// There's no module_templates.h, so this file is meant to be #include'd.
//
// Actually, it's proving too hard to separate the templates (which we want in
// the .hImpl) from the template specializations (which we want in the .cpp).
// So visdatmodule.cpp and bldmodule.cpp are now #include'ing
// module_templates.cpp (rather than module_templates.hImpl).  So we might as
// well go back to combining these two files.
//
#ifndef INCLUDED_MODULE_TEMPLATES_HIMPL
#define INCLUDED_MODULE_TEMPLATES_HIMPL

#include <Python.h>
#include <string>
#include <vector>
#include <map>
#include "../../utils/StatusCodes.h"
#include "../Intvect.h"
#include "../Box.h"
#include "../PointerHandleMap.h"
#include "VisualizableDatasetInterfaceForPython.h"
using std::string;
using std::vector;
using std::pair;


//
// ParseTraits template struct.  Used by *adicPythonFunc() family.
//
template<typename T> struct ParseTraits
{
    typedef int ParseType; // This should always be specialized
    string ScanCode() {
        assert(0); // This should always be specialized
        return "should never get here";
    }
    PyObject * RetVal( Status s ) {
        assert(0); // This should always be specialized
        return 0;
    }
    T Convert( ParseType a) {
        assert(0); // This should always be specialized
        T t;
        return t;
    }
};


/** When T is a scalar, this is specialized in the cpp file.  This is the
 *  general case, and it handles (among other things) the case of T a vector. */
template<> template<typename T> struct ParseTraits<vector<T> >
{
    PyObject * RetVal( vector<T> vpo )
    {
        ParseTraits<T> pt;
        PyObject * result;
        result = PyTuple_New( vpo.size() );
        for( unsigned i=0;i<vpo.size();++i )
        {
            PyTuple_SetItem( result, i, pt.RetVal(vpo[i]) );
        }
        return result;
    }
};


template<> template<typename T> struct ParseTraits<pair<T,T> >
{
    PyObject * RetVal( pair<T,T> vpo )
    {
        vector<T> vf;
        vf.push_back( vpo.first );
        vf.push_back( vpo.second );
        ParseTraits<vector<T> > pt;
        return pt.RetVal( vf );
    }
};


/** Will work for T a float or double. */
template<> template<typename T> struct ParseTraits<Triple<T> const &>
{
    string ScanCode() { return "O"; }
    typedef PyObject * ParseType;
    Triple<T> Convert(ParseType a)
    {
        assert( PyTuple_Check(a) );
        Triple<T> result;
        for( int i=0;i<3;++i )
        {
            result.m_data[i] = T( PyFloat_AsDouble(PyTuple_GetItem(a,i) ));
        }
        return result;
    }
    PyObject * RetVal( Triple<T> const & civ )
    {
        Triple<T> iv( civ );
        vector<T> vi( iv );
        ParseTraits<vector<T> > pt;
        return pt.RetVal( vi );
    }
};


/** Family of *adicPythonFunc().  Parse PyObject*args into objects of arbitrary
 *   types, and pass them to an arbitrary void-returning C++ function.
 *   If you need to parse to new types, add the appropriate specialization to
 *   the ParseTraits template above.  If you need to call functions of more args
 *   that allowed by the highest-order of the *adicPythonFunc family, then
 *   add one to the family; the pattern should be pretty self-evident.
 *
 *   For usage examples, see visdatmodule.cpp and bldmodule.cpp.
 *
 *   All the *adicPythonFunc()'s return None.  They could be generalized to
 *   return something else, though.
*/


//
// Niladic
//
template<class R, class FUNC_T, class C> PyObject *
SharedNiladicPythonFunc_guts( PyObject * args, FUNC_T pf )
{
    int intPtr;
    if( ! PyArg_ParseTuple( args, "i", &intPtr ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal( (pC->*pf)() );
}

template<class R, class C> PyObject *
SharedNiladicPythonFunc( R (C::*pf)() const, PyObject * args )
{
    typedef R (C::*PF)() const;
    return SharedNiladicPythonFunc_guts<R,PF,C>( args, pf );
}

template<class R, class C> PyObject *
SharedNiladicPythonFunc( R (C::*pf)(), PyObject * args )
{
    typedef R (C::*PF)();
    return SharedNiladicPythonFunc_guts<R,PF,C>( args, pf );
}


//
// Monadic
//
template<class R, class FUNC_T, class C, class A1> PyObject *
SharedMonadicPythonFunc_guts( PyObject * args, FUNC_T pf )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    ParseTraits<A1> A1Traits;
    string code( string("i") + A1Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr, &arg1 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal( (pC->*pf)( A1Traits.Convert(arg1) ) );
}

template<class R, class C, class A1> PyObject *
SharedMonadicPythonFunc( R (C::*pf)(A1) const, PyObject * args )
{
    typedef R (C::*PF)(A1) const;
    return SharedMonadicPythonFunc_guts<R,PF,C,A1>( args, pf );
}

template<class R, class C, class A1> PyObject *
SharedMonadicPythonFunc( R (C::*pf)(A1), PyObject * args )
{
    typedef R (C::*PF)(A1);
    return SharedMonadicPythonFunc_guts<R,PF,C,A1>( args, pf );
}


//
// Diadic.  Here we have two fairly different classes of functions.
// One is a function of two not-very-fancy (e.g. string, int, char)
// arguments: we call those A1 and A2.  The other kind takes just A2
// and instead of A1 it takes a pointer to an instance of class C.
//
template<class R, class FUNC_T, class C, class A1, class A2> PyObject *
SharedDiadicPythonFunc_guts(
    PyObject * args,
    FUNC_T pf )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    typename ParseTraits<A2>::ParseType arg2;
    ParseTraits<A1> A1Traits;
    ParseTraits<A2> A2Traits;
    C * pC;

    string code( string("i") + A1Traits.ScanCode() + A2Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr, &arg1, &arg2 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();

    return ParseTraits<R>().RetVal( (pC->*pf)(
        A1Traits.Convert(arg1), A2Traits.Convert(arg2) ) );
}


template<class R, class C, class A1, class A2> PyObject *
SharedDiadicPythonFunc( R (C::*pf)(A1,A2) const, PyObject * args )
{
    typedef R (C::*PF)(A1,A2) const;
    return SharedDiadicPythonFunc_guts<R,PF,C,A1,A2>( args, pf );
}


template<class R, class C, class A1, class A2> PyObject *
SharedDiadicPythonFunc( R (C::*pf)(A1,A2), PyObject * args )
{
    typedef R (C::*PF)(A1,A2);
    return SharedDiadicPythonFunc_guts<R,PF,C,A1,A2>( args, pf );
}


/** 
 *  Arg args typically carries bld_ptr, other_bld_ptr, boxNum
*/
template<class R, class FUNC_T, class C, class A2> PyObject *
SharedDiadicPythonFunc_guts( PyObject * args, FUNC_T pf )
{
    int intPtr;
    int intPtr2;
    typename ParseTraits<A2>::ParseType arg2;
    ParseTraits<A2> A2Traits;
    string code( string("ii") + A2Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr, &intPtr2, &arg2 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    boost::shared_ptr<C> pC2 = SharedPointerHandleMap<C>::GetPointer(intPtr2);
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal( (pC->*pf)( pC2, A2Traits.Convert(arg2) ) );
}

template<class R, class C, class A2> PyObject *
SharedDiadicPythonFunc( R (C::*pf)(boost::shared_ptr<C>,A2) const,
                                   PyObject * args )
{
    typedef R (C::*PF)(boost::shared_ptr<C>,A2) const;
    return SharedDiadicPythonFunc_guts<R,PF,C,A2>( args, pf );
}

template<class R, class C, class A2> PyObject *
SharedDiadicPythonFunc( R (C::*pf)(boost::shared_ptr<C>,A2),
                                   PyObject * args )
{
    typedef R (C::*PF)(boost::shared_ptr<C>,A2);
    return SharedDiadicPythonFunc_guts<R,PF,C,A2>( args, pf );
}


//
// Triadic
//
template<class R, class C, class A1, class A2, class A3> PyObject *
SharedTriadicPythonFunc( R (C::*pf)(A1,A2,A3) const, PyObject * args )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    typename ParseTraits<A2>::ParseType arg2;
    typename ParseTraits<A3>::ParseType arg3;
    ParseTraits<A1> A1Traits;
    ParseTraits<A2> A2Traits;
    ParseTraits<A3> A3Traits;
    string code( string("i") + A1Traits.ScanCode() + A2Traits.ScanCode()
               + A3Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr, &arg1, &arg2, &arg3 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal( (pC->*pf)(
        A1Traits.Convert(arg1), A2Traits.Convert(arg2),
        A3Traits.Convert(arg3) ));
}


//
// Tetradic
//
template<class R, class C, class A1, class A2, class A3, class A4> PyObject *
SharedTetradicPythonFunc( R (C::*pf)(A1,A2,A3,A4) const, PyObject * args )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    typename ParseTraits<A2>::ParseType arg2;
    typename ParseTraits<A3>::ParseType arg3;
    typename ParseTraits<A4>::ParseType arg4;
    ParseTraits<A1> A1Traits;
    ParseTraits<A2> A2Traits;
    ParseTraits<A3> A3Traits;
    ParseTraits<A4> A4Traits;
    string code( string("i") + A1Traits.ScanCode() + A2Traits.ScanCode()
               + A3Traits.ScanCode() + A4Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr, &arg1, &arg2, &arg3, &arg4 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    R result =  (pC->*pf)( A1Traits.Convert(arg1), A2Traits.Convert(arg2),
        A3Traits.Convert(arg3), A4Traits.Convert(arg4) );
    //cerr << "TetradicPythonFunc(" << A1Traits.Convert(arg1) << ","
    //     << A2Traits.Convert(arg2) << ","
    //     << A3Traits.Convert(arg3) << "," << A4Traits.Convert(arg4) << ")=|"
    //     << result << "|" << endl;
    return retvalConverter.RetVal( result );
}


//
// Pentadic
//
template<class R, class FUNC_T, class C,
         class A1, class A2, class A3, class A4, class A5> PyObject *
SharedPentadicPythonFunc_guts( PyObject * args, FUNC_T pf )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    typename ParseTraits<A2>::ParseType arg2;
    typename ParseTraits<A3>::ParseType arg3;
    typename ParseTraits<A4>::ParseType arg4;
    typename ParseTraits<A5>::ParseType arg5;
    ParseTraits<A1> A1Traits;
    ParseTraits<A2> A2Traits;
    ParseTraits<A3> A3Traits;
    ParseTraits<A4> A4Traits;
    ParseTraits<A5> A5Traits;
    string code( string("i")
        + A1Traits.ScanCode() + A2Traits.ScanCode() + A3Traits.ScanCode()
        + A4Traits.ScanCode() + A5Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr,
                            &arg1, &arg2, &arg3, &arg4, &arg5 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal(
        (pC->*pf)( A1Traits.Convert(arg1), A2Traits.Convert(arg2),
                   A3Traits.Convert(arg3), A4Traits.Convert(arg4),
                   A5Traits.Convert(arg5) ) );
}

template<class R, class C,
         class A1, class A2, class A3, class A4, class A5> PyObject *
SharedPentadicPythonFunc( R (C::*pf)(A1,A2,A3,A4,A5) const, PyObject * args )
{
    typedef R (C::*PF)(A1,A2,A3,A4,A5) const;
    return SharedPentadicPythonFunc_guts<R,PF,C,A1,A2,A3,A4,A5>( args, pf );
}
template<class R, class C,
         class A1, class A2, class A3, class A4, class A5> PyObject *
SharedPentadicPythonFunc( R (C::*pf)(A1,A2,A3,A4,A5), PyObject * args )
{
    typedef R (C::*PF)(A1,A2,A3,A4,A5);
    return SharedPentadicPythonFunc_guts<R,PF,C,A1,A2,A3,A4,A5>( args, pf );
}


//
// Hexadic
//
template<class R, class C,
         class A1, class A2, class A3, class A4, class A5, class A6> PyObject *
SharedHexadicPythonFunc( R (C::*pf)(A1,A2,A3,A4,A5,A6) const, PyObject * args )
{
    int intPtr;
    typename ParseTraits<A1>::ParseType arg1;
    typename ParseTraits<A2>::ParseType arg2;
    typename ParseTraits<A3>::ParseType arg3;
    typename ParseTraits<A4>::ParseType arg4;
    typename ParseTraits<A5>::ParseType arg5;
    typename ParseTraits<A6>::ParseType arg6;
    ParseTraits<A1> A1Traits;
    ParseTraits<A2> A2Traits;
    ParseTraits<A3> A3Traits;
    ParseTraits<A4> A4Traits;
    ParseTraits<A5> A5Traits;
    ParseTraits<A6> A6Traits;
    string code( string("i")
        + A1Traits.ScanCode() + A2Traits.ScanCode() + A3Traits.ScanCode()
        + A4Traits.ScanCode() + A5Traits.ScanCode() + A6Traits.ScanCode() );
    char * buf = new char[ code.size() + 1 ];
    strcpy( buf, code.c_str() );
    if( ! PyArg_ParseTuple( args, buf, &intPtr,
                            &arg1, &arg2, &arg3, &arg4, &arg5, &arg6 ) )
    {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyArg_ParseTuple failed." );
        return 0;
    }
    delete [] buf;

    C * pC = SharedPointerHandleMap<C>::GetPointer(intPtr).get();
    ParseTraits<R> retvalConverter;
    return retvalConverter.RetVal(
        (pC->*pf)( A1Traits.Convert(arg1), A2Traits.Convert(arg2),
                   A3Traits.Convert(arg3), A4Traits.Convert(arg4),
                   A5Traits.Convert(arg5), A4Traits.Convert(arg6) ) );
}


#endif // INCLUDED_MODULE_TEMPLATES_HIMPL
