/*
**   _______              __
**  / ___/ /  ___  __ _  / /  ___
** / /__/ _ \/ _ \/  ' \/ _ \/ _ \
** \___/_//_/\___/_/_/_/_.__/\___/ 
**
** This software is copyright (C) by the Lawrence Berkeley
** National Laboratory.  Permission is granted to reproduce
** this software for non-commercial purposes provided that
** this notice is left intact.
** 
** It is acknowledged that the U.S. Government has rights to
** this software under Contract DE-AC03-765F00098 between
** the U.S. Department of Energy and the University of
** California.
**
** This software is provided as a professional and academic
** contribution for joint exchange.  Thus it is experimental,
** is provided ``as is'', with no warranties of any kind
** whatsoever, no support, no promise of updates, or printed
** documentation.  By using this software, you acknowledge
** that the Lawrence Berkeley National Laboratory and
** Regents of the University of California shall have no
** liability with respect to the infringement of other
** copyrights by any part of this software.
**
*/
// Author: Ted Sternberg

#ifndef DEFINED_POINTER_HANDLE_MAP_HIMPL
#define DEFINED_POINTER_HANDLE_MAP_HIMPL

// We store the const and nonconst versions of the same class's pointers
// on the same SemiSymmetricMap of nonconst pointers.  Otherwise we'd have
// trouble finding them if the same pointer is passed as const or nonconst
// to different functions.

#define ARGT typename TypeOp<T>::ArgT
#define BARET typename TypeOp<T>::BareT
#define SBARETMAP SharedPointerHandleMap<typename TypeOp<T>::BareT>
#define SA_BARETMAP SharedArrayHandleMap<typename TypeOp<T>::BareT>

template<typename T> int
SharedPointerHandleMap<T>::GetHandle( boost::shared_ptr<T> p )
{
    if( ! SBARETMAP::s_map )
    {
        SBARETMAP::s_map = new SemiSymmetricMap<boost::shared_ptr<BARET> >;
    }
    return SBARETMAP::s_map->GetKey( boost::const_pointer_cast<BARET>(p) );
}

template<typename T> boost::shared_ptr<T>
SharedPointerHandleMap<T>::GetPointer( int k )
{
    assert( SBARETMAP::s_map );
    return boost::const_pointer_cast<ARGT>(SBARETMAP::s_map->GetValue( k ));
}


/** Remove, from s_map, the element with the indicated handle.
 *  Returns 0 on success, see ../utils/SemiSymmetricMap.hImpl for definition
 *    of what other return values mean.
*/
template<typename T> int
SharedPointerHandleMap<T>::RemoveByHandle( int k )
{
    return s_map->RemoveByKey( k );
}


//
// SharedArrayHandleMap: after this works, templatize to generalize
// SharedPointerHandleMap and SharedArrayHandleMap under one template.
//
template<typename T> int
SharedArrayHandleMap<T>::GetHandle( boost::shared_array<T> p )
{
    if( ! SA_BARETMAP::s_map )
    {
        SA_BARETMAP::s_map = new SemiSymmetricMap<boost::shared_array<BARET> >;
    }
    return SA_BARETMAP::s_map->GetKey( p );
}

template<typename T> boost::shared_array<T>
SharedArrayHandleMap<T>::GetPointer( int k )
{
    assert( SA_BARETMAP::s_map );
    return SA_BARETMAP::s_map->GetValue( k );
}


/** Remove, from s_map, the element with the indicated handle.
 *  Returns 0 on success, see ../utils/SemiSymmetricMap.hImpl for definition
 *    of what other return values mean.
*/
template<typename T> int
SharedArrayHandleMap<T>::RemoveByHandle( int k )
{
    return s_map->RemoveByKey( k );
}

#undef ARGT
#undef BARET
#undef SBARETMAP
#undef SA_BARETMAP

#endif // DEFINED_POINTER_HANDLE_MAP_HIMPL
