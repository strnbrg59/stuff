<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>Chombo HDF5 File Format Description</title>
  </head>

  <body bgcolor="#111111" text="#FFFFFF" link="#AFE3EA" vlink="#D6B5E0"
    alink="#FFAD00">

<CENTER><FONT SIZE=18> Chombo HDF5 File Format Description </FONT></CENTER>

<HR>
<TOC></TOC>
<HR>


<H1> Introduction </H1>

ChomboVis reads HDF5 files produced by Chombo, laid out in a format
closely matched to Chombo's needs and terminology.  This section is
for people who want to write such files without using Chombo.

<P> The easiest, but not the most computationally efficient, way to
produce a file in this format is to use our ascii2hdf5 tool, described
below.  You don't need to learn HDF5 and you can use a text editor to
tinker with your input file.  Unfortunately, every one of your ascii
numbers goes through the C language's <TT>atof</TT> function, and ascii2hdf5
is not a parallel algorithm either.

<P> For better performance, you will need to use the <a
href="http://hdf.ncsa.uiuc.edu/index.html">HDF5</a> library.

<H1> Data Descriptor Language </H1>

<P> What follows now is a description of the Chombo HDF5 format.  From
this description it is possible for someone with block-structured AMR
data and a knowledge of the HDF5 API to write data files that
ChomboVis and other Chombo applications will understand.

<P> Many data entries are optional.  They are indicated with the
[OPTIONAL] tag after their names.  In one case -- the "particles"
group -- an entire group is optional.

<P> Some data entries are repeated a number of times, for instance
there are a number of repeated level definitions.  For these cases,
the repeated entry is wrapped in a [for n=0,num] scope, with the `n'
being the increment character.

<P> Chombo uses the NATIVE data type internally, which allows
efficient conversions between binary data representations.  Every
NATIVE data type translates to a real data type for a particular
computer architecture.  Thus, where you see H5T_NATIVE_DOUBLE, you
might get binary data of the form H5T_IEEE_F64LE on Intel 32 bit
architectures.

<P> Floating point numbers in Chombo HDF5 files may be single or
double precision.  Thus, everywhere <TT>H5T_NATIVE_DOUBLE</TT> appears
below, you can substitute <TT>HDF5_NATIVE_FLOAT.</TT> (ChomboVis
figures out which one it is by checking the <TT>testReal</TT>
attribute.)

<P> Chombo users may, for their convenience or any other reason,
introduce into hdf5 files items not mentioned here.  ChomboVis ignores
such extra items, as long as their names do not collide, of course,
with the standard items listed here.

<P> We also define three composite HDF5 data types.  These depend on
the dimensionality of the Chombo HDF5 file; here they are for 3D.

<P>
<pre>
DATATYPE ``intvect_id'' {
  H5T_NATIVE_INT "intvecti";
  H5T_NATIVE_INT "intvectj";
  H5T_NATIVE_INT "intvectk";
         }

DATATYPE ``floatvect_id'' {
  H5T_NATIVE_DOUBLE "x";
  H5T_NATIVE_DOUBLE "y";
  H5T_NATIVE_DOUBLE "z";
         }

DATATYPE ``box_id''{
  H5T_NATIVE_INT "lo_i";
  H5T_NATIVE_INT "lo_j";
  H5T_NATIVE_INT "lo_k";
  H5T_NATIVE_INT "hi_i";
  H5T_NATIVE_INT "hi_j";
  H5T_NATIVE_INT "hi_k";
         }
</pre>
  
<P> With these definitions in hand, we can proceed with the layout
description.

<pre>
GROUP "/" {
   ATTRIBUTE "time" [OPTIONAL]{
      DATATYPE H5T_NATIVE_DOUBLE
      DATASPACE SCALAR
   }
   ATTRIBUTE "iteration" [OPTIONAL] {
      DATATYPE H5T_NATIVE_INT
      DATASPACE SCALAR
   }
   ATTRIBUTE "data_centering" [OPTIONAL] {
      DATATYPE H5T_NATIVE_INT
      DATASPACE SCALAR
   } # 0=cell, 1=x-face, 2=y-face, 3=z-face, 4=x-edge, 5=y-edge, 6=z-edge, 7=node.
   ATTRIBUTE "origin" [OPTIONAL] { 
      DATATYPE floatvect_id
      DATASPACE SCALAR
   } # Spatial location of lower corner of [0,0,0] cell.
   ATTRIBUTE "anisotropic" [OPTIONAL] { 
      DATATYPE floatvect_id
      DATASPACE SCALAR
   } # Stretches dx along x, y and z axes.
   ATTRIBUTE "num_levels" {
      DATATYPE H5T_NATIVE_INT
      DATASPACE SCALAR
   }
   ATTRIBUTE "max_level" {
      DATATYPE H5T_NATIVE_INT
      DATASPACE SCALAR
   } # Anachronism: must equal num_levels-1
   ATTRIBUTE "num_components" {
      DATATYPE H5T_NATIVE_INT
      DATASPACE SCALAR
   }
   [for n=0,num_components  
   ATTRIBUTE "component_n" {
      DATATYPE {
         { STRSIZE ;
           STRPAD H5T_STR_NULLTERM;
           CSET H5T_CSET_ASCII;
           CTYPE H5T_C_S1;
         }
      }
      DATASPACE SCALAR
   }]
   GROUP "Chombo_global" {
      ATTRIBUTE "testReal" {
         DATATYPE H5T_NATIVE_DOUBLE
         DATASPACE SCALAR
      }
      ATTRIBUTE "SpaceDim" {
         DATATYPE H5T_NATIVE_INT
         DATASPACE SCALAR
      }
   }
   [for n=0,num_levels
   GROUP "level_n" {
      ATTRIBUTE "dt" [OPTIONAL] {
         DATATYPE H5T_NATIVE_DOUBLE
         DATASPACE SCALAR
      }
      ATTRIBUTE "dx" {
         DATATYPE H5T_NATIVE_DOUBLE
         DATASPACE SCALAR
      }
      ATTRIBUTE "ref_ratio" {
         DATATYPE H5T_NATIVE_INT
         DATASPACE SCALAR
      }
      ATTRIBUTE "prob_domain" {
         DATATYPE box_id
         DATASPACE SCALAR
      }
      DATASET "boxes" {
         DATATYPE box_id
         DATASPACE {SIMPLE 1D}
      } # see section 'Data Flattening'
      DATASET "data:datatype=0" {
         DATATYPE H5T_NATIVE_DOUBLE
         DATASPACE {SIMPLE 1D}
      } # see section 'Data Flattening'
      GROUP "data_attributes" {
         ATTRIBUTE "ghost" {
            DATATYPE intvect_id
            DATASPACE SCALAR
         }
         ATTRIBUTE "comps" {
            DATATYPE H5T_NATIVE_INT
            DATASPACE SCALAR
         }
         ATTRIBUTE "objectType" {
            DATATYPE {
               { STRSIZE ;
                 STRPAD H5T_STR_NULLTERM;
                 CSET H5T_CSET_ASCII;
                 CTYPE H5T_C_S1;
               }
            }
            DATASPACE SCALAR
         }
      }
   }]

   # Particles data is not organized by level.
   GROUP "particles" [OPTIONAL] {
      ATTRIBUTE "num_components" {
         DATATYPE  H5T_NATIVE_INT
         DATASPACE  SCALAR
      }
      ATTRIBUTE "num_particles" {
         DATATYPE  H5T_NATIVE_INT
         DATASPACE  SCALAR
      }
      [for n=0,num_components
      DATASET component_name_n {
         DATATYPE  H5T_NATIVE_DOUBLE
         DATASPACE SCALAR # num_particles numbers
        }
      ] # component_name_n can be any string
    }
 }

</pre>
<h2> Data Flattening </h2>

Field data is stored, for each level, in a 1D HDF5 dataset.  From
fastest- to slowest-moving, the indices are i, j, k, box, and
component.  In other words, Fortran order, then box, then component.


<H1> The ascii2hdf5 tool </H1>

As mentioned above, the easy but computationally inefficient way to
produce a ChomboVis-legal HDF5 file is via our <A
HREF="Other_features.html">ascii2hdf5</A> tool.  This tool (found in
the libexec/ChomboVis directory, wherever you have installed
ChomboVis) reads an ascii file on standard input and produces a file
called <TT>ascii2hdf5-output.hdf5</TT> (unless you put
<TT>outfile=something.hdf5</TT> on the command line, in which case you
get <TT>something.hdf5</TT>).

<H1> ASCII layout </H1> <P> We will explain the ASCII format with the
following "commented" extract from examples/chomboascii.dat.  Beware
that ascii2hdf5.sh is not very tolerant to variations from the
prescribed format.  In particular: the items must appear in the order
shown; item names must be spelled exactly as shown; the colon is
obligatory, must be right up against the item name, and must be
followed by a whitespace character.  However, whitespace is not
(otherwise) significant; indentation and skipped lines are included
here solely for the benefit of human readers.  Comments are also OK;
anything after a '#' is ignored.  Note there is no "testReal" item, as
ascii2hdf5 always produces double-precision output.

<PRE>
space_dim: 3                     # 2 or 3
num_levels: 2                    # Number of levels of refinement
num_components: 2                # Number of data components
component_names: phi rhs         # If no components, say just "component_names:".

data_centering: 0                # 0=cell, 1=x-face, 2=y-face, 3=z-face,
                                 # 4=x-edge, 5=y-edge, 6=z-edge, 7=node.

prob_domain: 0 0 0 1 1 1         # Extreme corners of the problem domain, in    
                                 # units of level-0 cells.                      
                                 # If space_dim==2, there should be only four   
                                 # numbers -- integers -- here.                 

origin: 1.1 2.2 3.3              # Spatial location of lower corner of [0,0,0] cell.
anisotropic: 1.0 2.5 5.0         # Stretches dx along x, y and z axes.

level_0:                         # Level 0 metadata and data.               
    dx: 1.0                      # Size of the side of a cell.
                                 # (See "anisotropic scaling" on this page).

    dt: 0.3                      # Size of a time step

    time: 10.2                   # Time at beginning (or, optionally end) of run.

    output_ghost: 0 0 0          # Depth of ghost cells in x, y and (if space_dim  
                                 # ==3) z directions.  output_ghost must be the    
                                 # same for each level.  See under "Ghost cells"   
                                 # <A HREF="Visualization.html"> here.</A>         

    boxes:                       # Dimensions of the boxes, in cells (hence      
        0 0 0 1 1 1              # integers).  If there is more than one box,    
                                 # see under "level_1" below.  If space_dim==2,  
                                 # box dimensions are just four integers.        
                                 # This "0 0 0 1 1 1" indicates a 2x2x2 box.     

    data:                        # This is the data itself.  Whitespace is not   
        1 2   3 4                # significant, but we have provided it to help  
        5 6   7 8                # with eyeball parsing.  There are sixteen      
                                 # numbers here because we have one 2x2x2 box    
        1.1 1.2   1.3 1.4        # and two data components.  If you have too     
        2.5 2.6   2.7 2.8        # many or too few numbers here, ascii2hdf5      
                                 # fails, though not very gracefully.  The       
                                 # numbers are interpreted as double precision.
                                 #
                                 # From fastest- to slowest-changing, the data indices
                                 # are i, j, k, box, component.  Thus, Fortran order
                                 # within each box, and then box and component.
                                 # 
                                 # If there is no data (i.e. num_components==0)
                                 # you still need to say "data:" here.

level_1:                         # Level 1 metadata and data.  The conventions  
    dx: 0.5                      # are the same for every level.                
    dt: 0.1
    time: 10.18
    output_ghost: 0 0 0
    boxes:                       # Two boxes, both 2x4x4.
        0 0 0 1 3 3              
        2 0 0 3 3 3              
    data:                        # Two 2x4x4 boxes and two data components,  
        1 2   3 4                # hence 128 numbers.                        
        5 6   7 8
                                 
        1.1 1.2   1.3 1.4        
        2.5 2.6   2.7 2.8        
                                 
        1 2   3 4                
        5 6   7 8                
                                 
        1.1 1.2   1.3 1.4        
        2.5 2.6   2.7 2.8
                                 
        1 2   3 4                
        5 6   7 8
                                 
        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8
                                 
        1 2   3 4                
        5 6   7 8

        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8

        1 2   3 4
        5 6   7 8

        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8

        1 2   3 4
        5 6   7 8

        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8

        1 2   3 4
        5 6   7 8

        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8

        1 2   3 4
        5 6   7 8

        1.1 1.2   1.3 1.4
        2.5 2.6   2.7 2.8

particles:                        # This section is optional.  If you don't have
    num_components: 6             # particles, don't even say "particles:" here.
    num_particles: 5
    component_0:
        name: position_x
        values:  1.1 1.9 2.3 1.2 2.1
    component_1:
        name: position_y
        values:  2.2 3.7 3.5 3.2 2.3
    component_2:
        name: position_z
        values:  3.3 3.7 3.5 3.2 4.3
    component_3:
        name: particle_id
        values: 121 122 123 124 125
    component_4:
        name: mass
        values: 1 2 3 4 5
    component_5:
        name: charge
        values: 1.1 1.2 1.3 1.5 1.8
</PRE>
<P>

Our ASCII format is not very compact, but then you could write a
program that writes ASCII to standard out, pipe that to ascii2hdf5.sh,
and thus avoid the need to store an ASCII file at all.  Or you could
store your ASCII file in gzipped format and then "gunzip" onto
standard out, e.g.
<P>
<PRE>
    gzip -dc mystuff.dat.gz | ascii2hdf5.sh outfile=mystuff.hdf5
</PRE>
<P>

<P> The example file has cell-centered data.  To produce a file of
otherwise-centered data, use the appropriate code for the
"data_centering" field, and then make sure you provide the correct
number of data points.  An m by n box of cell-centered data contains
mn data points, but if the data are node-centered, the number of data
points should be (m+1)(n+1); x-face-centered would be (m+1)n; etc.

<address><a href="mailto:chombovis@davis.lbl.gov">ChomboVis Development Team</a></address>
</body>
</html>
