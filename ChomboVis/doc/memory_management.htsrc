<!-- This document should be absorbed into Architecture.htsrc -->

<H2> Memory management policies </H2>

<H3> class vtkChomboReader </H3>

Instances of vtkChomboReader are always created from Python; we never
obtain an instance in ChomboVis C++ code.  We use VTK's wrapping
mechanism and from there let Python/VTK worry about memory management.
vtkChomboReaders are cleaned up when they go out of scope or their
value is set to the Python None or 0.  In practice, vtkChomboReaders
are only cleaned up when we load a new hdf5 file (or at exit of
course).  Note vtkChomboReader inherits from vtkObject, with all the
memory-management implications of that.

<P> In ChomboVis, each instance of class VtkData and LocalVtkData
holds its own vtkChomboReader, as self.reader.  See VtkData.cleanup().


<H3> class vtkChomboReaderImpl </H3>

Each vtkChomboReader holds one pointer to a distinct
vtkChomboReaderImpl.  The vtkChomboReaderImpl is constructed as soon
as we want to associate the vtkChomboReader with a VisualizableDataset
(see vtkChomboReader::LoadFile() and vtkChomboReader::ShareFile()).

<P> The vtkChomboReaderImpl is destroyed from the vtkChomboReader
destructor, and from nowhere else.  (In principle, we could throw away
the Impl and construct a new one when we want to load a new file,
retaining the vtkChomboReader itself.  But we don't do that; we throw
away the vtkChomboReader too, when we want to load a new file.)

<P> vtkChomboReaderImpl derives from vtkChomboReader, and therefore
from vtkStrucutedPointsSource, but is not submitted to VTK's Python
wrapper.  The only access to vtkChomboReaderImpl is through
vtkChomboReader, where it is an implementation detail.  Nor does
vtkChomboReader ever serve up its Impl to anyone else.


<H3> class ChomboHDF5 </H3>

ChomboHDF5 is used internally by VisualizableDataset, as a handle to
the HDF5 file.  VisualizableDataset holds the ChomboHDF5 inside a
boost::shared_ptr.


<H3> class VisualizableDataset </H3>

In ChomboVis, a single VisualizableDataset instance -- held by
boost::share_ptr's -- is shared by all the vtkChomboReaderImpls.
As long as the VisualizableDataset is in use, there are at least three
references to it, two of these being from the two maps in SemiSymmetricMap.
These two references get flushed out when Python decides we don't need the
VisualizableDataset.


<H3> class BoxLayoutData </H3>

All BoxLayoutDatas (BLD for short) begin life as data members --
wrapped in boost::shared_ptr's -- of a VisualizableDataset.  BLDs can
live a more or less independent existence, but they originate in a
call to VisualizableDataset::GetBoxLayoutData() which returns a
boost::shared_pointer.  A fully-independent BLD can then be obtained
by calling Clone() on that pointer.

<H3> class FAB </H3>

All FABs are wrapped in boost::shared_ptr's.  (The two-stage refcounting system
based on boost::intrusive_ptr's is no more.  To read about it, check out a
version of this file from, oh, 9/7/2005.)

<P> FABs can be "pinned", either in VisualizableDataset or in BoxLayoutData.
What that means is that a copy of the smart pointer that holds the FAB is put
on a structure (called m_pinnedFabs).  That has the effect of bumping the
refcount up and preventing deletion of the FAB's FArray (until the BoxLayoutData
or VisualizableDataset itself is cleaned up, or we call UnpinFAB() on that FAB).
