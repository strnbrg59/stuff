#!/usr/local/bin/expect

################ Definition of TCL random function ################
proc random_init {seed} {
	global _ran;
	set _ran $seed;
}

proc urand {} {
	global _ran;
	set period 259200;
	set _ran [expr ($_ran*7141 + 54773) % $period];
#	expr $_ran/double($period);
    expr $_ran%10;
} 
############### end of TCL random function definition #############


## Spawn aqc and get into the order Tbill menu.
## This proc has to be followed by something else, as we are left
##	with aqc running.
proc poisson_order {} {
#	spawn aqc;
## If you "spawn aqc" in here, aqc becomes kind of a "local" process,
## which other procs apparently can't interact with.
	expect "knickname:";     # It doesn't see "knickname: " (w/ space)
	send "poisson\r";
	expect "password:";
	send "shbolet\r";
	expect "q to quit";
	send "T\r";
#	send "q\r";
#	expect;
} 
##--------------------------------

proc market_order { n_units } {
## Has to be called after poisson_order{}
	#expect "x to exit. >"	# Message inside security menu.
	# Unfortunately, this string isn't visible to this proc, as it
	# was produced while the previous proc was active, and therefore
	# got "absorbed" into its buffer, which is now gone.
	sleep 1;
	send "o\r"
	expect "limit order"
	send "m\r"
	expect "sell:"
	send "b\r"
	expect "units:"
	send "$n_units\r";
	expect "(y|n)"
	send "y\r"
#	sleep 1;
#	expect
} 
##-------------------------------

proc exit_aqc {} {
	sleep 1;
	send "x\r"
	expect "q to quit"
	send "q\r"
	expect		# Without this, aqc doesn't return.
} 
##--------------------------------

random_init 10;
spawn aqc;
poisson_order; ## Put it as [poisson_order] and you get an error!?
for { set i 0 } { $i < 4 } { incr i 1 } {
	sleep 1;
	market_order [urand];
}
exit_aqc;

