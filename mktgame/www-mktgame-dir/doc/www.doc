The goal now is to make aqc run on the WWW.

1. 	A problem that was minor in the past becomes significant now.  This
is the matter of players checking the order book, placing a market order,
then finding that the limit order they wanted has been taken.  
	The solution: cause limit orders to cross with each other, if the 
highest limit bid is >= the lowest limit ask.  This way, the worst thing
that can happen, when you try to snap up a very low ask, is that your
(limit) bid just stays on the book.
----------------------------------------------------------------------

2.  Overall Strategy 
The overall strategy is to change as little as possible!  Ideally, we 
could get this thing running on the WWW just by changing the user
interface.  And that, in only a minor way.  For example, already all our 
output to the user just goes to stdout.  Now we can just put a line

		Content-type: text/html

before each time we call printf.

User input will take a little more work; we'll have to use html forms.
----------------------------------------------------------------------

3. Compiler warnings.
Let's clean up the code so we don't get any more compiler warnings.  In
particular, we should make sure there are no "implicit declaration" 
warnings.  I notice, for example, there's one such in dump_cncttime(). 
We'll recall that the connect time functionality was always trouble-prone
(it would reset people's time allotments sporadically).
----------------------------------------------------------------------

4. Start-up.  The first thing that happens is that main() calls
get_usridpwd(), which uses curses to prompt the user.  Let's change that
so main() receives the name and password as command-line arguments
(can these be seen with ps??).  Have an html form collect the userid
and password, and pass them to main().
----------------------------------------------------------------------

				Security Concerns We Must Deal With

5. The password file, even though it's not readable by the "world", does
lie in the cgi-bin directory.  Therefore anyone (on rahul, anyway) can
simply copy the password file to himself, and look at it there.

6. Virtual html forms must identify the user not just by name but by
password as well.  Otherwise anyone can execute an order for anyone
else by just invoking CGIbldordr and sending it the user's name in
stdin.  Eventually, you should encrypt the password using some
technique that produces a different encrypted version every time, so
that if someone intercepts the transmission, he can't retransmit and
execute on behalf of someone else.

I am beginning to remedy this problem.  I've started with disp_choices1()
(called by CGInamepwd), making it send the password as a hidden variable.
Now I'm working on the program that is the ACTION invoked by the virtual
html file produced by disp_choices1().  

OK, done for CGImenu1, CGImenu2 and CGIbldordr.  Yet to do: CGIcancel
and CGIoptions.

------------------------------------------------------------------------

                    ----- Utility Programs ----- 

7. Poisson
Looks like poisson compiles, links and runs with no changes necessary
(i.e. no changes relative to the pre-www version).  That's great.
8. Initact
Ditto, works right out of the box.
9. Exdiv
Ditto.
10. Discwind
Ditto.


------------------------------------------------------------------------

                ----------- Debugging -----------

We can't get very far if every time there's a problem all we see is
Netscape's all-purpose message about a "configuration problem" with
our server.  What we have to be able to do is run the CGI* programs
outside Netscape, i.e. from the command line or from gdb.

The problem is what to do about POST arguments.  From the command
line, we can pipe them to the CGI program.  But in gdb, I don't know
how to put something into stdin.  So the strategy there will be that
we have the Html_argument_array constructor look first in a file
cin.debug, before it tries to read from stdin (cin).  Thus we just put
whatever we need into cin.debug.

A good convention is to make every CGI program deliver the "cout <<
HTML" command before it does anything.  That way, error messages will
(usually) get displayed by Netscape.  And no other functions
(e.g. ones called by the CGI programs) should deliver the "cout <<
HTML" command; it would be superfluous.  

To see the HTML arguments that have been passed to your CGI program,
just uncomment the "cout << buf" line in html-util.cpp.
