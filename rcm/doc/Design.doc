Let's rewrite rpnprog, but use reference-counted matrices.  Matrices
are otherwise always used as automatic variables, and we pass matrix
objects (rather than pointers) in function argument lists.  So we get
copy semantics.  But we make sure that no unnecessary copying ever
gets done.

M's elements are objects of class V, so that we can refer to M
elements with [][].  V is also reference-counted, and has public ctors
and getters/setters; it's fully useful for users needing vectors, not
matrices.

Neither M nor V hold any internal state, other than a pointer to their
associated Mrep or Vrep.  This saves space and time, besides removing
redundancy (Mrep and Vrep need to know their own dimensions anyway, e.g.
for destruction).

Bounds-checking: We check bounds in V and M's operator[] if the
environment variable DBG is set to 1.

Copy-on-write.  We copy-on-write automatically, unless environment
variable RCM_MANUAL_COW is set to 1.  In that case, the application
programmer has to call M::dup() before initiating a call to the setter
version of operator[].  If, in addition to RCM_MANUAL_COW=1, we also
have DEBUG=1, then we check that reference counts are indeed 1 when
the setter version of operator[] is called (and issue an error if it's
not).  Use RCM_MANUAL_COW=1 for maximum speed (though at a cost in
programming complexity).

Return values.  Math operations always return an object (either an M
or a V).  Not a reference, not a const reference.  This is for
consistency with typical math operations on built-in types.  Returning
references would be bad because our M's and V's will be automatic
variables, and it's bad to return a reference to something that's
about to go out of scope.

All math operations are global functions.  We don't provide +=, -=,
*=, /= etc, because they don't make sense for non-numeric M<T>.  If we
provided such operators as member functions, then we wouldn't be able
to instantiate M<T> for T a bool or a string.

All functions involving numerical manipulations (pretty much
everything but transp) are provided only for M<double>.  For the same
reason we don't provide += etc as member functions (see above); if we
provided so much as an operator+(M<T>), then we wouldn't be able to
instantiate M<T> for any T that doesn't have an operator+ defined for
it.

To avoid duplication, we don't define the same operations on V and M.
We only define them on M, and provide a conversion function, the
M::M(const V&) ctor.

V is either a row or a column -- these are values of an enum.  The
M(const V&) ctor uses this to determine if the M it constructs has
just a single column or just a single row.
